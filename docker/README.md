# Docker

## Using docker-compose

You may build your changes by using the compose file:

    docker-compose -f ./docker/docker-compose.yml up

## Entering the build environment

While in the repository root, to enter the environment and be presented with a
shell:

    docker run -it --rm \
      -e HOSTUID=$(id -u) -e HOSTGID=$(id -g)\
      -v $PWD:/workspace ghcr.io/KaruroChori/vs-fltk:build-env "bash -l"

This will mount your current directory as */workspace* inside the container.
Your username will be *builder*. By default, you will not have root privileges
(which are not necessary to build and test). However, you can use `sudo` if
you need to run `apt` or any other commands that require root access.

## Getting the image

You can pull the image manually:

    docker pull ghcr.io/KaruroChori/vs-fltk:build-env

If you use `docker-compose` or `docker run ...` the image will be pulled
automatically the first time.

## Running the app from the container

Note the following instructions were adapted from instructions generated by
ChatGPT. The X11 instructions were tested on Manjaro Linux. Use at your own
risk. Please update these docs if you have any information about accuracy or
security-related considerations.

To run an application from a Docker container that requires access to the host
machine's graphics (such as a GUI application), you'll need to share certain
resources from the host with the container. This involves passing through the
host's display (X11 or Wayland, depending on your system) and sharing the
necessary devices. Here's a general guide:

### For X11-based systems (e.g., most Linux desktop environments)

1. **Install dependencies on the host:**
   Make sure you have `xhost` installed, which allows you to control access to
   the X server.

    sudo apt install x11-xserver-utils  # For Ubuntu/Debian
    sudo pacman -S xorg-xhost  # For Arch-based


2. **Allow access to X server:**
   Before running the container, allow Docker to access your X server:

    xhost +local:docker


3. **Run the container with access to the display:**
   When starting the container, pass the display environment variable
   (`$DISPLAY`) and mount the X11 socket:

```bash
docker run -it --rm \
  -v $PWD:/workspace \
  --env="DISPLAY" \
  --env="QT_X11_NO_MITSHM=1" \
  --volume="/tmp/.X11-unix:/tmp/.X11-unix:rw" \
  ghcr.io/KaruroChori/vs-fltk:build-env
```

   - `--env="DISPLAY"`: Passes the display from the host to the container.
   - `--env="QT_X11_NO_MITSHM=1"`: Some applications may need this to avoid shared memory issues.
   - `--volume="/tmp/.X11-unix:/tmp/.X11-unix:rw"`: Shares the X11 socket.

4. **Run the graphical application inside the container:**
   Once inside the container, running the app should open its GUI on your host's screen.

### For Wayland-based systems (e.g., some modern Linux environments):

1. **Share the Wayland display:**
   If your system uses Wayland, you need to pass the Wayland display and devices:

```bash
docker run -it --rm -u builder \
  -v $PWD:/workspace \
  --env="WAYLAND_DISPLAY=$WAYLAND_DISPLAY" \
  --volume="/run/user/$(id -u)/wayland:/run/user/$(id -u)/wayland" \
  --device=/dev/dri \
  ghcr.io/KaruroChori/vs-fltk:build-env
```

   - `--env="WAYLAND_DISPLAY=$WAYLAND_DISPLAY"`: Passes the Wayland display variable.
   - `--volume="/run/user/$(id -u)/wayland:/run/user/$(id -u)/wayland"`: Shares the Wayland display socket.
   - `--device=/dev/dri`: Provides access to GPU devices (for rendering).

### Additional considerations:

- **GPU access**: If your application requires GPU acceleration (e.g.,
OpenGL), you may also need to pass through GPU devices to the container. For
example, with NVIDIA, you can use the NVIDIA Docker runtime:

   docker run --gpus all -it ghcr.io/KaruroChori/vs-fltk:build-env

- **X11 access security**: Allowing Docker to connect to your X server with `xhost +local:docker` is not secure. After you're done, revoke access:

    xhost -local:docker
