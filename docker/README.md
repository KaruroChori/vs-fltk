# Docker

## Using docker-compose

You may build your changes by using the compose file. First create an `.env`
file in /docker. The contents should be similar to that of `.env.example`:

```text
# Add your numeric user and group id
HOSTUID=
HOSTGID=

# The directory in the container where the source root will be mounted
WORKSPACE="/vs-workspace"
```

Replace the values for `HOSTUID` and `HOSTGID` with your system `uid` and `gid`.  
Then, from the source root, to enter the build environment:

```sh
docker-compose -f docker/docker-compose.yml run --rm  dev
```

From there, you can run the commands to build the app. You can use your
regular IDE to make changes, and then test them by building within the
container.

To start the container and build the app non-interactively:

```sh
export ENTRYPOINT=/entry-build.sh
```

And use the same command as shown above.

Remember to unset `ENTRYPOINT` when you wish to start the container with only
a prompt.

All of the above methods will mount your current directory as _/vs-workspace_
inside the container. Your username will be _builder_. By default, you will
not have root privileges (which are not necessary to build and test). However,
you can use `sudo` if you need to run `apt` or any other commands that require
root access.

## Notes

### Changing the default environmental variables

If you wish to change some values or variables, you should not need to edit
`docker-compose.yml`. You can add variables used in the compose file to your
`.env' file or pass them on the command line at runtime. See [Environment
variables in
Compose](https://docs.docker.com/compose/how-tos/environment-variables/) for
more information. And of course, open an issue if you have suggestions for
improvements.

### Working with Containers

In the examples above, we've included `--rm` as an argument. This normally
removes the container after it's exited. `docker ps -a` displays containers
that still exist, so you may periodically want to make sure you don't have
unused or unwanted containers. See the official [Docker
docs](https://docs.docker.com/) for more information about working with
containers. You may, for example, want to "reuse" a container, in which case,
simply omit the `--rm`.

## Getting the image

You can pull the image manually:

```sh
docker pull ghcr.io/karurochori/vs-fltk:build-env
```

If you use `docker-compose` or `docker run ...` the image will be pulled
automatically the first time.

## Running the app from the container

> [!WARNING]
> Note the following instructions were adapted from some generated by
> ChatGPT.  
> The X11 instructions were tested on Manjaro Linux. Use at your own
> risk.  
> Please update these docs if you have any information about accuracy or
> security-related considerations.

To run an application from a Docker container that requires access to the host
machine's graphics (such as a GUI application), you'll need to share certain
resources from the host with the container. This involves passing through the
host's display (X11 or Wayland, depending on your system) and sharing the
necessary devices. Here's a general guide:

### For X11-based systems (e.g., most Linux desktop environments)

1. **Install dependencies on the host:**
   Make sure you have `xhost` installed, which allows you to control access to
   the X server.

   ```
   sudo apt install x11-xserver-utils  # For Ubuntu/Debian
   sudo pacman -S xorg-xhost  # For Arch-based
   ```

2. **Allow access to X server:**
   Before running the container, allow Docker to access your X server:

   ```
   xhost +local:docker
   ```

3. **Run the container with access to the display:**
   When starting the container, pass the display environment variable
   (`$DISPLAY`) and mount the X11 socket. Instead of *dev" for the last
   argument of `docker-compose` (see above), use *xgui\*, which essentially
   adds these three arguments (through the compose configuration):

   ```sh
   --env="DISPLAY" \
   --env="QT_X11_NO_MITSHM=1" \
   --volume="/tmp/.X11-unix:/tmp/.X11-unix:rw"
   ```

   - `--env="DISPLAY"`: Passes the display from the host to the container.
   - `--env="QT_X11_NO_MITSHM=1"`: Some applications may need this to avoid shared memory issues.
   - `--volume="/tmp/.X11-unix:/tmp/.X11-unix:rw"`: Shares the X11 socket.

4. **Run the graphical application inside the container:**
   Once inside the container, running the app should open its GUI on your host's screen.

### For Wayland-based systems (e.g., some modern Linux environments):

1. **Share the Wayland display:**
   If your system uses Wayland, you need to pass the Wayland display and devices:

   ```sh
   --env="WAYLAND_DISPLAY=$WAYLAND_DISPLAY" \
   --volume="/run/user/$(id -u)/wayland:/run/user/$(id -u)/wayland" \
   --device=/dev/dri \
   ```

   - `--env="WAYLAND_DISPLAY=$WAYLAND_DISPLAY"`: Passes the Wayland display variable.
   - `--volume="/run/user/$(id -u)/wayland:/run/user/$(id -u)/wayland"`: Shares the Wayland display socket.
   - `--device=/dev/dri`: Provides access to GPU devices (for rendering).

### Additional considerations:

- **GPU access**: If your application requires GPU acceleration (e.g.,
  OpenGL), you may also need to pass through GPU devices to the container. For
  example, with NVIDIA, you can use the NVIDIA Docker runtime:
  `   --gpus all -it
`
- **X11 access security**: Allowing Docker to connect to your X server with `xhost +local:docker` is not secure. After you're done, revoke access:
  ```
  xhost -local:docker
  ```
